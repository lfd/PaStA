#!/usr/bin/env python3

"""
PaStA - Patch Stack Analysis

Copyright (c) University of Passau, 2021

Authors:
   Thomas Kirz <thomas.kirz@gmail.com>
   Pia Eichinger <pia.eichinger@hotmail.de>

This work is licensed under the terms of the GNU GPL, version 2. See
the COPYING file in the top-level directory.
"""

import os
import math
import pathlib
import re
import argparse
import textwrap

PROPERTIES = [
    {"colour": "blue", "x": 0, "y": 4, "layout": "spring electrical layout, node distance=2cm"},
    {"colour": "red", "x": -3, "y": 0, "layout": "spring electrical layout, node distance=2cm"},
    {"colour": "green", "x": 1, "y": -3, "layout": "spring electrical layout, node distance=3.5cm"}
]

SIZE_FACTOR = 0.3

MAIN_CLUSTERS = ["ARM PORT", "NETWORKING [GENERAL]", "DOCUMENTATION"]

def edge_line_factor(edge_weight):
    if edge_weight < 1000:
        return 0.3
    elif edge_weight < 3000:
        return 1
    elif edge_weight < 10000:
        return 2
    else:
        return 3

class Cluster:
    def __init__(self, cluster_id, cluster_name, layout, min_size, isolated):
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.layout = layout
        self.min_size = int(min_size)
        self.isolated = isolated
        self.adjust_cluster_name()

    def __gt__(self, cluster):
        return self.min_size > cluster.min_size

    def __str__(self) -> str:
        return self.cluster_id

    def adjust_cluster_name(self):
        # replace '_'s and remove line breaks
        self.cluster_name = self.cluster_name.replace("_", "\\_").replace("\\n", " ")


class Edge:
    def __init__(self, head, tail, line_width):
        self.head = head
        self.tail = tail
        self.line_width = int(line_width)

    def __str__(self) -> str:
        return "%s--%s [%d]" % (self.head, self.tail, self.line_width)

    # use this function to determine if an edge contains a cluster
    def has_cluster(self, cluster):
        return self.head == cluster or self.tail == cluster


def main():
    # everything in round brackets () is considered a 'group', a variable from
    # a string that we wish to extract and use as variables. Our groups:
    # group 1: cluster_id, such as cluster9 
    # group 2: section name, such as DOCUMENTATION
    # group 3: layout, such as circle
    # group 4: value of minimum size, such as 28
    CLUSTER_REGEX = re.compile(r'(cluster[0-9]*)\/"(.*)"\[draw, (.*), minimum size=(.*)\];')

    # groups for edge regexes:
    # group 1: head of edge (not really important, since we're in an undirected graph)
    # group 2: line width
    # group 3: tail of edge
    EDGE_REGEX = re.compile(r'(cluster[0-9]*)--\[line width=(.*)\](cluster[0-9]*)')

    parser = argparse.ArgumentParser(description="Daumenkino-Tex-File Parser")
    parser.add_argument("-i", type=str, help="path to input tex file, generated by R script", required=True)
    parser.add_argument("-o", type=str, help="path to output directory", required=True)
    parser.add_argument("--debug", action="store_true", help="display cluster name labels")

    args = parser.parse_args()
    last_cluster_names = []

    file_handle = open(args.i, 'r')
    lines = file_handle.readlines()

    cluster_dict = {}

    # skip all lines will the first delimiter (should not be needed tho)
    while not lines[0].startswith("%%% clusters"):
        lines.pop(0)

    # the first line is the delimiter that we searched for, we can pop that
    lines.pop(0)

    def parse_cluster_line(line):
        match = CLUSTER_REGEX.match(line)
        return match.group(1), match.group(2), match.group(3), match.group(4)

    # read in and save all cluster till we reach the isolated ones
    while not lines[0].startswith("%%% isolated"):
        # retrieve all the necessary parameters all at once from our helper function
        cluster_id, cluster_name, layout, min_size = parse_cluster_line(lines[0])

        # save a cluster object in our cluster dictionary. We set isolated as false, since
        # we only regard the non-isolated ones so far
        cluster_dict[cluster_id] = Cluster(cluster_id, cluster_name, layout, min_size, isolated=False)
        lines.pop(0)

    # pop the line, since it's a delimiter line again
    lines.pop(0)

    while not lines[0].startswith("%%% edges"):
        # same procedure as before
        cluster_id, cluster_name, layout, min_size = parse_cluster_line(lines[0])

        # same as before, but we set isolated as true
        cluster_dict[cluster_id] = Cluster(cluster_id, cluster_name, layout, min_size, isolated=True)
        lines.pop(0)

    # pop delimiter again
    lines.pop(0)

    edge_list = []

    # only edges now, which we also save in our edge list
    for line in lines:
        match = EDGE_REGEX.match(line)
        head = match.group(1)
        line_width = match.group(2)
        tail = match.group(3)

        edge_list.append(Edge(head, tail, line_width))

    # divide into subgraphs
    subgraph_list = []
    subgraph_edges_list = []
    next_clusters_list = []

    # use the biggest clusters as the main clusters for each subgraph
    for main_name in MAIN_CLUSTERS:
        cluster_key = next(c.cluster_id for c in cluster_dict.values() if c.cluster_name == main_name)
        next_clusters_list.append([cluster_dict.pop(cluster_key)])
        subgraph_list.append([])
        subgraph_edges_list.append([])

    # add neighbours to the subgraphs with a breadth-first search
    edges_remaining = True
    while cluster_dict and edges_remaining:
        edges_remaining = False
        for i in range(len(MAIN_CLUSTERS)):
            if next_clusters_list[i]:
                sg = subgraph_list[i]

                # add cluster from queue to the subgraph
                next_cluster = next_clusters_list[i].pop()
                sg.append(next_cluster)

                # edges connected to this cluster
                edges = [e for e in edge_list if e.has_cluster(next_cluster.cluster_id)]

                if edges:
                    edges_remaining = True
                    for e in edges:
                        if e.tail == next_cluster.cluster_id:
                            if e.head in cluster_dict:
                                next_clusters_list[i].append(cluster_dict.pop(e.head))
                                subgraph_edges_list[i].append(e)
                                edge_list.remove(e)
                        else:
                            if e.tail in cluster_dict:
                                next_clusters_list[i].append(cluster_dict.pop(e.tail))
                                subgraph_edges_list[i].append(e)
                                edge_list.remove(e)

    # add remaining clusters in next_clusters_list
    for i in range(len(MAIN_CLUSTERS)):
        for c in next_clusters_list[i]:
            subgraph_list[i].append(c)

    # opening the output path in written mode, name of file_handle is 'f'
    with open(args.o, 'w') as f:
        f.write("\\begin{tikzpicture}[\n")
        f.write("   every node/.style={align=center,font=\\Huge}\n")
        f.write("]\n")

        # writing the subgraphs
        for i in range(len(MAIN_CLUSTERS)):
            gp = PROPERTIES[i]
            f.write("\n\n%% Subgraph %d\n" % i)
            f.write("\\begin{scope}[shift={(%dcm,%dcm)}]\n" % (gp["x"], gp["y"]))
            f.write("\\graph[%s] {\n" % gp["layout"])

            for cluster in subgraph_list[i]:
                # every %s is a place holder for a string. The resulting string will be the
                # the string plus all variables in the tuple after it inserted
                label = cluster.cluster_name if args.debug else ""
                if last_cluster_names and cluster.cluster_name not in last_cluster_names:
                    cluster.layout = cluster.layout.replace("circle", "rectangle")

                f.write("%s/\"%s\"[draw, %s, minimum size=%dpt, text width=%dpt, fill=%s!25];\n" % (
                    cluster.cluster_id, label, cluster.layout, math.sqrt(cluster.min_size * SIZE_FACTOR),
                    cluster.min_size * 1.2 * SIZE_FACTOR, gp["colour"]))

            f.write("\n%%%edges%%%\n")
            for e in subgraph_edges_list[i]:
                f.write("%s--[line width=%.2fpt]%s;\n" % (e.head, edge_line_factor(e.line_width), e.tail))

            f.write("};\n")
            f.write("\\end{scope}\n")

        f.write("\n\n% Remaining edges\n")
        f.write("\\begin{scope}[on background layer]\n")
        for e in edge_list:
            f.write("\\draw[line width=%.2fpt] (%s) edge (%s);\n" % (edge_line_factor(e.line_width), e.head, e.tail))
        f.write("\\end{scope}\n")

        f.write("\\end{tikzpicture}")

    # save all clusters for comparison with next graph
    last_cluster_names = []
    for subgraph in subgraph_list:
        last_cluster_names += [cluster.cluster_name for cluster in subgraph]

# try running with: python3 daumenkino.py --file linux_v3_0.tex --output_path output.tex
if __name__ == '__main__':
    ret = main()
